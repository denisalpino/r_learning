
# функция, которая удаляет переменные
rm

# функция со сторонним эффектом, принимает значение из-вне и преобразовывает его
function_name <- function(x) {
   moredogs <<- x + 10
   return(moredogs)
}

# обыкновенная функция, является постоянной и всегда возвращает одинаковое
# значение
function_name <- function() {
   x <- x + 1
   return(x)
}

--------------------------------
# ОБЗИЙ ГЛОССАРИЙ ЗА 1 УРОК
?help
?help.search
?"<-"
?ls # то же, что и окно enviroment
?"function"
?rm # удаляет объект
?rnorm
--------------------------------

# создаение вектора
x <- c(13, 666, c('alpino'), TRUE, NA)
print(x)

# создание вектора с шагом 1
x<- 5:-2
print(x)

# создание вектора с установленным шагом
x <- seq(0, 1, by = 0.25)
print(x)

# создание вектора определенной длинны
x <- seq(0, 1, length = 5)
print(x)

# создание циклического (повторяющегося) вектора
x <- rep(0:1, times = 3)
print(x)

# создание циклического (повторяющегося) вектора, где повторяется каждый элемент
x <- rep(0:1, each = 3)
print(x)

# создание циклического (повторяющегося) вектора определенной длинны
x <- rep(0:1, length.out = 3)
print(x)

# Practice

u <- seq(0, 1, 1/3)
v <- seq(0, 1, 1/7)
c(u, v)

w <- unique(sort(c(u, v)))

# Проименованные (двумерные) вектора
a <- c(first = 1, second = 2, third = 3, 4)
print(a)
names(a) <- c('one', 'two', 'three', 'four')
print(a)

--------------------------------
# ОБЩИЙ ГЛОССАРИЙ ЗА 2 УРОК
?c
?":"
?seq
?rep
?print


?sum #суммирует значения, при булевых значениях является каунтером
?all.equal # проверяет эквивалентность чисел с плавающей запятой
?typeof
?is.logical

#преобразовывают переменную в указанный тип данных
?as.logical
?as.integer
?as.character
?as.numeric

?length
?names # функция, присваивающая атрибут имени каждой колонке списка
-------------------------------- 

# Условные выражения обыкновенные
if (1 > 0) {
  print('Mickey win!')
} else
  print('Mickey will eat them')

# Условное выражение сокращенное
ifelse(runif(8) > 0.5, 'Орел', 'Решка')

# Вложенное условное выражение
x <- runif(8)
ifelse(x > 2/3, 'Ножницы',
       ifelse(x > 1/3, 'Камень', 'Бумага')
       )

# Множественный выбор
switch('factorial',
       sum = 5 + 5,
       product = 5 * 5,
       factorial = factorial(5),
       0)


# Цикл repeat (while)
i <- 0
repeat {
  i <- i + runif(1)
  if (i > 5) break
  print(i)
}

# Цикл for
for (i in 1:8) {
  ifelse(i %% 2 == 0,
         print('Четное'),
         print('Нечетное')
         )
}

for (i in letters) {
  if (i == 'b') next
  if (i == 'd') break
  print(i)
}


# Practice

# Цикличный подход к подсчету корней значений списка в 22 раза медленнее
v <- 1:1e7
system.time({
  x <- 0
  for (i in v) x[i] <- sqrt(v[i])
})

#Векторный подход к подсчету корней каждого значения из списка в 22 раза быстрее
v <- 1:1e7
system.time({
  x <- sqrt(v)
})

# Задание на поиск значений в пределах от -0.2 до 0.3
set.seed(1337)
x <- runif(1e6, min = -1, max = 1)
sum(x <= 0.3 & x >= -0.2)


# Написать кубик для игры в монополию
dice_roll <- function(n) {
  as.integer(runif(n, 1, 7))
}

-------------------------------- 
  
# ОБЩИЙ ГЛОССАРИЙ ЗА 3 УРОК
?if
?ifelse
?switch
?Logic
?repeat
?while
?for
?installed.packages
?library
?require
?install.packages
?update.packages
?sessionInfo

-------------------------------- 
  
# Обращение к элементам вектора

x <- seq(10, 100, 10)
x[1]
x[3:4]
x[c(8, 7, 3, 6:8, x[1])]

x[-5]
x[-(2:6)]
x[c(-3, -5, -length(x), -5)]

x[rep(c(TRUE, FALSE))] # нечетные
x[c(FALSE, TRUE)] # четные

x[ x > 77 & x < 99]

a[c("two", "one", "three", "four", "error")] # индексация именного вектора

# Функции ALL и ANY

all(x < 200); all(x > 20) # проверка на условие

# Функиця WHICH

which(x >= 50) # возвращает индексы значений, удовлетворяющих условию
which.max(x) # возвращает индекс максимального значения
which.min(x) # возвращает индекс минимального значения

# Атрибуты объекта

x <- c(5, 3, 9)
names(x) <- c("V", "III", "IX") # присваиваем вектору атрибут имени
attr(x, "author") <- "Caesar" # создаем свой собственный новый атрибут
attributes(x)

# Practice

# Соседи с большей разницей

set.seed(42)
x <- sample(1:100, 50)

k <- which.max(abs(x[-1] - x[-length(x)])) # вычитаем из последовательности n 
# последовательность n-1, затем берем модуль разницы и ищем позицию
# максимального значения
x[c(k, k+1)]

# Определение нестрогой монотонности

is_monotone <- function(x) {
  all(x[-length(x)] <= x[-1]) | all(x[-length(x)] >= x[-1])
}














